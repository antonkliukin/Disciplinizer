//
// This is a generated file, do not edit!
// Generated by R.swift, see https://github.com/mac-cain13/R.swift
//

import Foundation
import Rswift
import UIKit

/// This `R` struct is generated and contains references to static resources.
struct R: Rswift.Validatable {
  fileprivate static let applicationLocale = hostingBundle.preferredLocalizations.first.flatMap(Locale.init) ?? Locale.current
  fileprivate static let hostingBundle = Bundle(for: R.Class.self)

  /// Find first language and bundle for which the table exists
  fileprivate static func localeBundle(tableName: String, preferredLanguages: [String]) -> (Foundation.Locale, Foundation.Bundle)? {
    // Filter preferredLanguages to localizations, use first locale
    var languages = preferredLanguages
      .map(Locale.init)
      .prefix(1)
      .flatMap { locale -> [String] in
        if hostingBundle.localizations.contains(locale.identifier) {
          if let language = locale.languageCode, hostingBundle.localizations.contains(language) {
            return [locale.identifier, language]
          } else {
            return [locale.identifier]
          }
        } else if let language = locale.languageCode, hostingBundle.localizations.contains(language) {
          return [language]
        } else {
          return []
        }
      }

    // If there's no languages, use development language as backstop
    if languages.isEmpty {
      if let developmentLocalization = hostingBundle.developmentLocalization {
        languages = [developmentLocalization]
      }
    } else {
      // Insert Base as second item (between locale identifier and languageCode)
      languages.insert("Base", at: 1)

      // Add development language as backstop
      if let developmentLocalization = hostingBundle.developmentLocalization {
        languages.append(developmentLocalization)
      }
    }

    // Find first language for which table exists
    // Note: key might not exist in chosen language (in that case, key will be shown)
    for language in languages {
      if let lproj = hostingBundle.url(forResource: language, withExtension: "lproj"),
         let lbundle = Bundle(url: lproj)
      {
        let strings = lbundle.url(forResource: tableName, withExtension: "strings")
        let stringsdict = lbundle.url(forResource: tableName, withExtension: "stringsdict")

        if strings != nil || stringsdict != nil {
          return (Locale(identifier: language), lbundle)
        }
      }
    }

    // If table is available in main bundle, don't look for localized resources
    let strings = hostingBundle.url(forResource: tableName, withExtension: "strings", subdirectory: nil, localization: nil)
    let stringsdict = hostingBundle.url(forResource: tableName, withExtension: "stringsdict", subdirectory: nil, localization: nil)

    if strings != nil || stringsdict != nil {
      return (applicationLocale, hostingBundle)
    }

    // If table is not found for requested languages, key will be shown
    return nil
  }

  /// Load string from Info.plist file
  fileprivate static func infoPlistString(path: [String], key: String) -> String? {
    var dict = hostingBundle.infoDictionary
    for step in path {
      guard let obj = dict?[step] as? [String: Any] else { return nil }
      dict = obj
    }
    return dict?[key] as? String
  }

  static func validate() throws {
    try intern.validate()
  }

  #if os(iOS) || os(tvOS)
  /// This `R.storyboard` struct is generated, and contains static references to 12 storyboards.
  struct storyboard {
    /// Storyboard `Ad`.
    static let ad = _R.storyboard.ad()
    /// Storyboard `Alert`.
    static let alert = _R.storyboard.alert()
    /// Storyboard `Blocked`.
    static let blocked = _R.storyboard.blocked()
    /// Storyboard `CreateChallenge`.
    static let createChallenge = _R.storyboard.createChallenge()
    /// Storyboard `CurrentChallenge`.
    static let currentChallenge = _R.storyboard.currentChallenge()
    /// Storyboard `Guide`.
    static let guide = _R.storyboard.guide()
    /// Storyboard `History`.
    static let history = _R.storyboard.history()
    /// Storyboard `LaunchScreen`.
    static let launchScreen = _R.storyboard.launchScreen()
    /// Storyboard `MotivationSelection`.
    static let motivationSelection = _R.storyboard.motivationSelection()
    /// Storyboard `PageNavigation`.
    static let pageNavigation = _R.storyboard.pageNavigation()
    /// Storyboard `Settings`.
    static let settings = _R.storyboard.settings()
    /// Storyboard `TimeSelection`.
    static let timeSelection = _R.storyboard.timeSelection()

    #if os(iOS) || os(tvOS)
    /// `UIStoryboard(name: "Ad", bundle: ...)`
    static func ad(_: Void = ()) -> UIKit.UIStoryboard {
      return UIKit.UIStoryboard(resource: R.storyboard.ad)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIStoryboard(name: "Alert", bundle: ...)`
    static func alert(_: Void = ()) -> UIKit.UIStoryboard {
      return UIKit.UIStoryboard(resource: R.storyboard.alert)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIStoryboard(name: "Blocked", bundle: ...)`
    static func blocked(_: Void = ()) -> UIKit.UIStoryboard {
      return UIKit.UIStoryboard(resource: R.storyboard.blocked)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIStoryboard(name: "CreateChallenge", bundle: ...)`
    static func createChallenge(_: Void = ()) -> UIKit.UIStoryboard {
      return UIKit.UIStoryboard(resource: R.storyboard.createChallenge)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIStoryboard(name: "CurrentChallenge", bundle: ...)`
    static func currentChallenge(_: Void = ()) -> UIKit.UIStoryboard {
      return UIKit.UIStoryboard(resource: R.storyboard.currentChallenge)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIStoryboard(name: "Guide", bundle: ...)`
    static func guide(_: Void = ()) -> UIKit.UIStoryboard {
      return UIKit.UIStoryboard(resource: R.storyboard.guide)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIStoryboard(name: "History", bundle: ...)`
    static func history(_: Void = ()) -> UIKit.UIStoryboard {
      return UIKit.UIStoryboard(resource: R.storyboard.history)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIStoryboard(name: "LaunchScreen", bundle: ...)`
    static func launchScreen(_: Void = ()) -> UIKit.UIStoryboard {
      return UIKit.UIStoryboard(resource: R.storyboard.launchScreen)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIStoryboard(name: "MotivationSelection", bundle: ...)`
    static func motivationSelection(_: Void = ()) -> UIKit.UIStoryboard {
      return UIKit.UIStoryboard(resource: R.storyboard.motivationSelection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIStoryboard(name: "PageNavigation", bundle: ...)`
    static func pageNavigation(_: Void = ()) -> UIKit.UIStoryboard {
      return UIKit.UIStoryboard(resource: R.storyboard.pageNavigation)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIStoryboard(name: "Settings", bundle: ...)`
    static func settings(_: Void = ()) -> UIKit.UIStoryboard {
      return UIKit.UIStoryboard(resource: R.storyboard.settings)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIStoryboard(name: "TimeSelection", bundle: ...)`
    static func timeSelection(_: Void = ()) -> UIKit.UIStoryboard {
      return UIKit.UIStoryboard(resource: R.storyboard.timeSelection)
    }
    #endif

    fileprivate init() {}
  }
  #endif

  /// This `R.color` struct is generated, and contains static references to 13 colors.
  struct color {
    /// Color `AppColor`.
    static let appColor = Rswift.ColorResource(bundle: R.hostingBundle, name: "AppColor")
    /// Color `BackgroundBlue`.
    static let backgroundBlue = Rswift.ColorResource(bundle: R.hostingBundle, name: "BackgroundBlue")
    /// Color `CTBlack`.
    static let ctBlack = Rswift.ColorResource(bundle: R.hostingBundle, name: "CTBlack")
    /// Color `CTBlue`.
    static let ctBlue = Rswift.ColorResource(bundle: R.hostingBundle, name: "CTBlue")
    /// Color `CTGray`.
    static let ctGray = Rswift.ColorResource(bundle: R.hostingBundle, name: "CTGray")
    /// Color `CTOrange`.
    static let ctOrange = Rswift.ColorResource(bundle: R.hostingBundle, name: "CTOrange")
    /// Color `CTPurple`.
    static let ctPurple = Rswift.ColorResource(bundle: R.hostingBundle, name: "CTPurple")
    /// Color `CTWhite`.
    static let ctWhite = Rswift.ColorResource(bundle: R.hostingBundle, name: "CTWhite")
    /// Color `DarkBlueText`.
    static let darkBlueText = Rswift.ColorResource(bundle: R.hostingBundle, name: "DarkBlueText")
    /// Color `LightBlue`.
    static let lightBlue = Rswift.ColorResource(bundle: R.hostingBundle, name: "LightBlue")
    /// Color `LightGreyText`.
    static let lightGreyText = Rswift.ColorResource(bundle: R.hostingBundle, name: "LightGreyText")
    /// Color `NavigationItemSelected`.
    static let navigationItemSelected = Rswift.ColorResource(bundle: R.hostingBundle, name: "NavigationItemSelected")
    /// Color `buttonLightBlue`.
    static let buttonLightBlue = Rswift.ColorResource(bundle: R.hostingBundle, name: "buttonLightBlue")

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "AppColor", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func appColor(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.appColor, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "BackgroundBlue", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func backgroundBlue(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.backgroundBlue, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "CTBlack", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func ctBlack(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.ctBlack, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "CTBlue", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func ctBlue(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.ctBlue, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "CTGray", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func ctGray(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.ctGray, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "CTOrange", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func ctOrange(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.ctOrange, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "CTPurple", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func ctPurple(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.ctPurple, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "CTWhite", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func ctWhite(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.ctWhite, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "DarkBlueText", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func darkBlueText(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.darkBlueText, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "LightBlue", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func lightBlue(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.lightBlue, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "LightGreyText", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func lightGreyText(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.lightGreyText, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "NavigationItemSelected", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func navigationItemSelected(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.navigationItemSelected, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "buttonLightBlue", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func buttonLightBlue(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.buttonLightBlue, compatibleWith: traitCollection)
    }
    #endif

    fileprivate init() {}
  }

  /// This `R.file` struct is generated, and contains static references to 8 files.
  struct file {
    /// Resource file `Config.plist`.
    static let configPlist = Rswift.FileResource(bundle: R.hostingBundle, name: "Config", pathExtension: "plist")
    /// Resource file `Distant Place.mp3`.
    static let distantPlaceMp3 = Rswift.FileResource(bundle: R.hostingBundle, name: "Distant Place", pathExtension: "mp3")
    /// Resource file `Floating Point.mp3`.
    static let floatingPointMp3 = Rswift.FileResource(bundle: R.hostingBundle, name: "Floating Point", pathExtension: "mp3")
    /// Resource file `GoogleService-Info.plist`.
    static let googleServiceInfoPlist = Rswift.FileResource(bundle: R.hostingBundle, name: "GoogleService-Info", pathExtension: "plist")
    /// Resource file `Leaving Wonderland.mp3`.
    static let leavingWonderlandMp3 = Rswift.FileResource(bundle: R.hostingBundle, name: "Leaving Wonderland", pathExtension: "mp3")
    /// Resource file `Long Days.mp3`.
    static let longDaysMp3 = Rswift.FileResource(bundle: R.hostingBundle, name: "Long Days", pathExtension: "mp3")
    /// Resource file `Metting The Sun.mp3`.
    static let mettingTheSunMp3 = Rswift.FileResource(bundle: R.hostingBundle, name: "Metting The Sun", pathExtension: "mp3")
    /// Resource file `Pillow Talk.mp3`.
    static let pillowTalkMp3 = Rswift.FileResource(bundle: R.hostingBundle, name: "Pillow Talk", pathExtension: "mp3")

    /// `bundle.url(forResource: "Config", withExtension: "plist")`
    static func configPlist(_: Void = ()) -> Foundation.URL? {
      let fileResource = R.file.configPlist
      return fileResource.bundle.url(forResource: fileResource)
    }

    /// `bundle.url(forResource: "Distant Place", withExtension: "mp3")`
    static func distantPlaceMp3(_: Void = ()) -> Foundation.URL? {
      let fileResource = R.file.distantPlaceMp3
      return fileResource.bundle.url(forResource: fileResource)
    }

    /// `bundle.url(forResource: "Floating Point", withExtension: "mp3")`
    static func floatingPointMp3(_: Void = ()) -> Foundation.URL? {
      let fileResource = R.file.floatingPointMp3
      return fileResource.bundle.url(forResource: fileResource)
    }

    /// `bundle.url(forResource: "GoogleService-Info", withExtension: "plist")`
    static func googleServiceInfoPlist(_: Void = ()) -> Foundation.URL? {
      let fileResource = R.file.googleServiceInfoPlist
      return fileResource.bundle.url(forResource: fileResource)
    }

    /// `bundle.url(forResource: "Leaving Wonderland", withExtension: "mp3")`
    static func leavingWonderlandMp3(_: Void = ()) -> Foundation.URL? {
      let fileResource = R.file.leavingWonderlandMp3
      return fileResource.bundle.url(forResource: fileResource)
    }

    /// `bundle.url(forResource: "Long Days", withExtension: "mp3")`
    static func longDaysMp3(_: Void = ()) -> Foundation.URL? {
      let fileResource = R.file.longDaysMp3
      return fileResource.bundle.url(forResource: fileResource)
    }

    /// `bundle.url(forResource: "Metting The Sun", withExtension: "mp3")`
    static func mettingTheSunMp3(_: Void = ()) -> Foundation.URL? {
      let fileResource = R.file.mettingTheSunMp3
      return fileResource.bundle.url(forResource: fileResource)
    }

    /// `bundle.url(forResource: "Pillow Talk", withExtension: "mp3")`
    static func pillowTalkMp3(_: Void = ()) -> Foundation.URL? {
      let fileResource = R.file.pillowTalkMp3
      return fileResource.bundle.url(forResource: fileResource)
    }

    fileprivate init() {}
  }

  /// This `R.image` struct is generated, and contains static references to 9 images.
  struct image {
    /// Image `bar-icon-25`.
    static let barIcon25 = Rswift.ImageResource(bundle: R.hostingBundle, name: "bar-icon-25")
    /// Image `history_icon`.
    static let history_icon = Rswift.ImageResource(bundle: R.hostingBundle, name: "history_icon")
    /// Image `launch_cat`.
    static let launch_cat = Rswift.ImageResource(bundle: R.hostingBundle, name: "launch_cat")
    /// Image `launch_title`.
    static let launch_title = Rswift.ImageResource(bundle: R.hostingBundle, name: "launch_title")
    /// Image `music.note.list`.
    static let musicNoteList = Rswift.ImageResource(bundle: R.hostingBundle, name: "music.note.list")
    /// Image `play.fill`.
    static let playFill = Rswift.ImageResource(bundle: R.hostingBundle, name: "play.fill")
    /// Image `play`.
    static let play = Rswift.ImageResource(bundle: R.hostingBundle, name: "play")
    /// Image `settings_icon`.
    static let settings_icon = Rswift.ImageResource(bundle: R.hostingBundle, name: "settings_icon")
    /// Image `tracker_icon`.
    static let tracker_icon = Rswift.ImageResource(bundle: R.hostingBundle, name: "tracker_icon")

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "bar-icon-25", bundle: ..., traitCollection: ...)`
    static func barIcon25(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.barIcon25, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "history_icon", bundle: ..., traitCollection: ...)`
    static func history_icon(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.history_icon, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "launch_cat", bundle: ..., traitCollection: ...)`
    static func launch_cat(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.launch_cat, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "launch_title", bundle: ..., traitCollection: ...)`
    static func launch_title(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.launch_title, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "music.note.list", bundle: ..., traitCollection: ...)`
    static func musicNoteList(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.musicNoteList, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "play", bundle: ..., traitCollection: ...)`
    static func play(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.play, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "play.fill", bundle: ..., traitCollection: ...)`
    static func playFill(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.playFill, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "settings_icon", bundle: ..., traitCollection: ...)`
    static func settings_icon(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.settings_icon, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "tracker_icon", bundle: ..., traitCollection: ...)`
    static func tracker_icon(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.tracker_icon, compatibleWith: traitCollection)
    }
    #endif

    fileprivate init() {}
  }

  /// This `R.nib` struct is generated, and contains static references to 2 nibs.
  struct nib {
    /// Nib `ChallengeParameterView`.
    static let challengeParameterView = _R.nib._ChallengeParameterView()
    /// Nib `PageCollectionViewCell`.
    static let pageCollectionViewCell = _R.nib._PageCollectionViewCell()

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "ChallengeParameterView", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.challengeParameterView) instead")
    static func challengeParameterView(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.challengeParameterView)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "PageCollectionViewCell", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.pageCollectionViewCell) instead")
    static func pageCollectionViewCell(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.pageCollectionViewCell)
    }
    #endif

    static func challengeParameterView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
      return R.nib.challengeParameterView.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
    }

    static func pageCollectionViewCell(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> PageCollectionViewCell? {
      return R.nib.pageCollectionViewCell.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? PageCollectionViewCell
    }

    fileprivate init() {}
  }

  /// This `R.reuseIdentifier` struct is generated, and contains static references to 3 reuse identifiers.
  struct reuseIdentifier {
    /// Reuse identifier `PageCollectionViewCell`.
    static let pageCollectionViewCell: Rswift.ReuseIdentifier<PageCollectionViewCell> = Rswift.ReuseIdentifier(identifier: "PageCollectionViewCell")
    /// Reuse identifier `SongSelectCell`.
    static let songSelectCell: Rswift.ReuseIdentifier<SongSelectCell> = Rswift.ReuseIdentifier(identifier: "SongSelectCell")
    /// Reuse identifier `challengeCellId`.
    static let challengeCellId: Rswift.ReuseIdentifier<HistoryChallengeCell> = Rswift.ReuseIdentifier(identifier: "challengeCellId")

    fileprivate init() {}
  }

  /// This `R.string` struct is generated, and contains static references to 5 localization tables.
  struct string {
    /// This `R.string.createChallenge` struct is generated, and contains static references to 11 localization keys.
    struct createChallenge {
      /// ru translation: 10 Min
      ///
      /// Locales: ru
      static let bB1OBWLText = Rswift.StringResource(key: "5bB-1O-bWL.text", tableName: "CreateChallenge", bundle: R.hostingBundle, locales: ["ru"], comment: nil)
      /// ru translation: CHOSE MODE
      ///
      /// Locales: ru
      static let fdTLOVmText = Rswift.StringResource(key: "1fd-TL-OVm.text", tableName: "CreateChallenge", bundle: R.hostingBundle, locales: ["ru"], comment: nil)
      /// ru translation: Free
      ///
      /// Locales: ru
      static let ct5JMG5NSegmentTitles1 = Rswift.StringResource(key: "Ct5-JM-g5N.segmentTitles[1]", tableName: "CreateChallenge", bundle: R.hostingBundle, locales: ["ru"], comment: nil)
      /// ru translation: In order to take a challenge, please select a desired mode
      ///
      /// Locales: ru
      static let fa1Dt5rsText = Rswift.StringResource(key: "fa1-Dt-5rs.text", tableName: "CreateChallenge", bundle: R.hostingBundle, locales: ["ru"], comment: nil)
      /// ru translation: Let's get down to business!
      ///
      /// Locales: ru
      static let dEz3MSYgText = Rswift.StringResource(key: "DEz-3M-sYg.text", tableName: "CreateChallenge", bundle: R.hostingBundle, locales: ["ru"], comment: nil)
      /// ru translation: Paid
      ///
      /// Locales: ru
      static let ct5JMG5NSegmentTitles0 = Rswift.StringResource(key: "Ct5-JM-g5N.segmentTitles[0]", tableName: "CreateChallenge", bundle: R.hostingBundle, locales: ["ru"], comment: nil)
      /// ru translation: Price
      ///
      /// Locales: ru
      static let pBl73EjcText = Rswift.StringResource(key: "pBl-73-Ejc.text", tableName: "CreateChallenge", bundle: R.hostingBundle, locales: ["ru"], comment: nil)
      /// ru translation: SET TIME
      ///
      /// Locales: ru
      static let jsvBS0eZText = Rswift.StringResource(key: "jsv-bS-0eZ.text", tableName: "CreateChallenge", bundle: R.hostingBundle, locales: ["ru"], comment: nil)
      /// ru translation: Start
      ///
      /// Locales: ru
      static let cctOF4TYNormalTitle = Rswift.StringResource(key: "cct-OF-4TY.normalTitle", tableName: "CreateChallenge", bundle: R.hostingBundle, locales: ["ru"], comment: nil)
      /// ru translation: YOUR BET
      ///
      /// Locales: ru
      static let ed98gRUEText = Rswift.StringResource(key: "ed9-8g-RUE.text", tableName: "CreateChallenge", bundle: R.hostingBundle, locales: ["ru"], comment: nil)
      /// ru translation: Новый
      ///
      /// Locales: ru
      static let ejRfSwgTitle = Rswift.StringResource(key: "2EJ-rf-Swg.title", tableName: "CreateChallenge", bundle: R.hostingBundle, locales: ["ru"], comment: nil)

      /// ru translation: 10 Min
      ///
      /// Locales: ru
      static func bB1OBWLText(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("5bB-1O-bWL.text", tableName: "CreateChallenge", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "CreateChallenge", preferredLanguages: preferredLanguages) else {
          return "5bB-1O-bWL.text"
        }

        return NSLocalizedString("5bB-1O-bWL.text", tableName: "CreateChallenge", bundle: bundle, comment: "")
      }

      /// ru translation: CHOSE MODE
      ///
      /// Locales: ru
      static func fdTLOVmText(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("1fd-TL-OVm.text", tableName: "CreateChallenge", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "CreateChallenge", preferredLanguages: preferredLanguages) else {
          return "1fd-TL-OVm.text"
        }

        return NSLocalizedString("1fd-TL-OVm.text", tableName: "CreateChallenge", bundle: bundle, comment: "")
      }

      /// ru translation: Free
      ///
      /// Locales: ru
      static func ct5JMG5NSegmentTitles1(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("Ct5-JM-g5N.segmentTitles[1]", tableName: "CreateChallenge", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "CreateChallenge", preferredLanguages: preferredLanguages) else {
          return "Ct5-JM-g5N.segmentTitles[1]"
        }

        return NSLocalizedString("Ct5-JM-g5N.segmentTitles[1]", tableName: "CreateChallenge", bundle: bundle, comment: "")
      }

      /// ru translation: In order to take a challenge, please select a desired mode
      ///
      /// Locales: ru
      static func fa1Dt5rsText(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("fa1-Dt-5rs.text", tableName: "CreateChallenge", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "CreateChallenge", preferredLanguages: preferredLanguages) else {
          return "fa1-Dt-5rs.text"
        }

        return NSLocalizedString("fa1-Dt-5rs.text", tableName: "CreateChallenge", bundle: bundle, comment: "")
      }

      /// ru translation: Let's get down to business!
      ///
      /// Locales: ru
      static func dEz3MSYgText(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("DEz-3M-sYg.text", tableName: "CreateChallenge", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "CreateChallenge", preferredLanguages: preferredLanguages) else {
          return "DEz-3M-sYg.text"
        }

        return NSLocalizedString("DEz-3M-sYg.text", tableName: "CreateChallenge", bundle: bundle, comment: "")
      }

      /// ru translation: Paid
      ///
      /// Locales: ru
      static func ct5JMG5NSegmentTitles0(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("Ct5-JM-g5N.segmentTitles[0]", tableName: "CreateChallenge", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "CreateChallenge", preferredLanguages: preferredLanguages) else {
          return "Ct5-JM-g5N.segmentTitles[0]"
        }

        return NSLocalizedString("Ct5-JM-g5N.segmentTitles[0]", tableName: "CreateChallenge", bundle: bundle, comment: "")
      }

      /// ru translation: Price
      ///
      /// Locales: ru
      static func pBl73EjcText(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("pBl-73-Ejc.text", tableName: "CreateChallenge", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "CreateChallenge", preferredLanguages: preferredLanguages) else {
          return "pBl-73-Ejc.text"
        }

        return NSLocalizedString("pBl-73-Ejc.text", tableName: "CreateChallenge", bundle: bundle, comment: "")
      }

      /// ru translation: SET TIME
      ///
      /// Locales: ru
      static func jsvBS0eZText(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("jsv-bS-0eZ.text", tableName: "CreateChallenge", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "CreateChallenge", preferredLanguages: preferredLanguages) else {
          return "jsv-bS-0eZ.text"
        }

        return NSLocalizedString("jsv-bS-0eZ.text", tableName: "CreateChallenge", bundle: bundle, comment: "")
      }

      /// ru translation: Start
      ///
      /// Locales: ru
      static func cctOF4TYNormalTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("cct-OF-4TY.normalTitle", tableName: "CreateChallenge", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "CreateChallenge", preferredLanguages: preferredLanguages) else {
          return "cct-OF-4TY.normalTitle"
        }

        return NSLocalizedString("cct-OF-4TY.normalTitle", tableName: "CreateChallenge", bundle: bundle, comment: "")
      }

      /// ru translation: YOUR BET
      ///
      /// Locales: ru
      static func ed98gRUEText(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("ed9-8g-RUE.text", tableName: "CreateChallenge", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "CreateChallenge", preferredLanguages: preferredLanguages) else {
          return "ed9-8g-RUE.text"
        }

        return NSLocalizedString("ed9-8g-RUE.text", tableName: "CreateChallenge", bundle: bundle, comment: "")
      }

      /// ru translation: Новый
      ///
      /// Locales: ru
      static func ejRfSwgTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("2EJ-rf-Swg.title", tableName: "CreateChallenge", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "CreateChallenge", preferredLanguages: preferredLanguages) else {
          return "2EJ-rf-Swg.title"
        }

        return NSLocalizedString("2EJ-rf-Swg.title", tableName: "CreateChallenge", bundle: bundle, comment: "")
      }

      fileprivate init() {}
    }

    /// This `R.string.history` struct is generated, and contains static references to 5 localization keys.
    struct history {
      /// ru translation: Duration
      ///
      /// Locales: ru
      static let iVpHgORqText = Rswift.StringResource(key: "IVp-hg-ORq.text", tableName: "History", bundle: R.hostingBundle, locales: ["ru"], comment: nil)
      /// ru translation: Is paid
      ///
      /// Locales: ru
      static let k91GZbText = Rswift.StringResource(key: "10K-91-gZb.text", tableName: "History", bundle: R.hostingBundle, locales: ["ru"], comment: nil)
      /// ru translation: Is success
      ///
      /// Locales: ru
      static let qMeRrUexText = Rswift.StringResource(key: "qMe-Rr-Uex.text", tableName: "History", bundle: R.hostingBundle, locales: ["ru"], comment: nil)
      /// ru translation: История
      ///
      /// Locales: ru
      static let mzHK2TF2Title = Rswift.StringResource(key: "mzH-k2-TF2.title", tableName: "History", bundle: R.hostingBundle, locales: ["ru"], comment: nil)
      /// ru translation: Отчистить
      ///
      /// Locales: ru
      static let ufGQ7CfMNormalTitle = Rswift.StringResource(key: "UfG-q7-cfM.normalTitle", tableName: "History", bundle: R.hostingBundle, locales: ["ru"], comment: nil)

      /// ru translation: Duration
      ///
      /// Locales: ru
      static func iVpHgORqText(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("IVp-hg-ORq.text", tableName: "History", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "History", preferredLanguages: preferredLanguages) else {
          return "IVp-hg-ORq.text"
        }

        return NSLocalizedString("IVp-hg-ORq.text", tableName: "History", bundle: bundle, comment: "")
      }

      /// ru translation: Is paid
      ///
      /// Locales: ru
      static func k91GZbText(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("10K-91-gZb.text", tableName: "History", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "History", preferredLanguages: preferredLanguages) else {
          return "10K-91-gZb.text"
        }

        return NSLocalizedString("10K-91-gZb.text", tableName: "History", bundle: bundle, comment: "")
      }

      /// ru translation: Is success
      ///
      /// Locales: ru
      static func qMeRrUexText(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("qMe-Rr-Uex.text", tableName: "History", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "History", preferredLanguages: preferredLanguages) else {
          return "qMe-Rr-Uex.text"
        }

        return NSLocalizedString("qMe-Rr-Uex.text", tableName: "History", bundle: bundle, comment: "")
      }

      /// ru translation: История
      ///
      /// Locales: ru
      static func mzHK2TF2Title(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("mzH-k2-TF2.title", tableName: "History", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "History", preferredLanguages: preferredLanguages) else {
          return "mzH-k2-TF2.title"
        }

        return NSLocalizedString("mzH-k2-TF2.title", tableName: "History", bundle: bundle, comment: "")
      }

      /// ru translation: Отчистить
      ///
      /// Locales: ru
      static func ufGQ7CfMNormalTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("UfG-q7-cfM.normalTitle", tableName: "History", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "History", preferredLanguages: preferredLanguages) else {
          return "UfG-q7-cfM.normalTitle"
        }

        return NSLocalizedString("UfG-q7-cfM.normalTitle", tableName: "History", bundle: bundle, comment: "")
      }

      fileprivate init() {}
    }

    /// This `R.string.launchScreen` struct is generated, and contains static references to 0 localization keys.
    struct launchScreen {
      fileprivate init() {}
    }

    /// This `R.string.localizable` struct is generated, and contains static references to 24 localization keys.
    struct localizable {
      /// en translation: %#@value@
      ///
      /// Locales: en, ru
      static let timerMinLeft = Rswift.StringResource(key: "timer.minLeft", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: 1. Set task time.  2. Make a bet. You might choose between time and money, it will highly increase your motivation!  3. The main rule is simple - do not leave the app. You can lock your phone or stay on the challenge screen.
      ///
      /// Locales: ru, en
      static let guideSecondPageContent = Rswift.StringResource(key: "guide.secondPage.content", tableName: "Localizable", bundle: R.hostingBundle, locales: ["ru", "en"], comment: nil)
      /// en translation: Big Coin
      ///
      /// Locales: en
      static let motivationItemBigCoin = Rswift.StringResource(key: "motivationItem.bigCoin", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en"], comment: nil)
      /// en translation: Click to avoid losing!
      ///
      /// Locales: ru, en
      static let notificationsReturnTitle = Rswift.StringResource(key: "notifications.return.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["ru", "en"], comment: nil)
      /// en translation: Does your task require concentration?
      ///
      /// Locales: ru, en
      static let guideSecondPageTitle = Rswift.StringResource(key: "guide.secondPage.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["ru", "en"], comment: nil)
      /// en translation: Follow the rules, stay focused and remember — time is money and you might lose it!
      ///
      /// Locales: ru, en
      static let guideThirdPageContent = Rswift.StringResource(key: "guide.thirdPage.content", tableName: "Localizable", bundle: R.hostingBundle, locales: ["ru", "en"], comment: nil)
      /// en translation: Got it!
      ///
      /// Locales: ru, en
      static let guideGotIt = Rswift.StringResource(key: "guide.gotIt", tableName: "Localizable", bundle: R.hostingBundle, locales: ["ru", "en"], comment: nil)
      /// en translation: Hello!
      ///
      /// Locales: ru, en
      static let guideFirstPageTitle = Rswift.StringResource(key: "guide.firstPage.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["ru", "en"], comment: nil)
      /// en translation: Huge Coin
      ///
      /// Locales: en
      static let motivationItemHugeCoin = Rswift.StringResource(key: "motivationItem.hugeCoin", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en"], comment: nil)
      /// en translation: In order to unlock the app you need to make a purchase equal to your challenge bet
      ///
      /// Locales: ru, en
      static let purchaseLoseMessage = Rswift.StringResource(key: "purchase.loseMessage", tableName: "Localizable", bundle: R.hostingBundle, locales: ["ru", "en"], comment: nil)
      /// en translation: Localized string
      ///
      /// Locales: ru, en
      static let alertExample = Rswift.StringResource(key: "alert.example", tableName: "Localizable", bundle: R.hostingBundle, locales: ["ru", "en"], comment: nil)
      /// en translation: Medium Coin
      ///
      /// Locales: en
      static let motivationItemMediumCoin = Rswift.StringResource(key: "motivationItem.mediumCoin", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en"], comment: nil)
      /// en translation: Motivation
      ///
      /// Locales: ru, en
      static let creationMotivationTitle = Rswift.StringResource(key: "creation.motivationTitle", tableName: "Localizable", bundle: R.hostingBundle, locales: ["ru", "en"], comment: nil)
      /// en translation: Next
      ///
      /// Locales: ru, en
      static let guideNext = Rswift.StringResource(key: "guide.next", tableName: "Localizable", bundle: R.hostingBundle, locales: ["ru", "en"], comment: nil)
      /// en translation: Skip
      ///
      /// Locales: ru, en
      static let guideSkip = Rswift.StringResource(key: "guide.skip", tableName: "Localizable", bundle: R.hostingBundle, locales: ["ru", "en"], comment: nil)
      /// en translation: Small Coin
      ///
      /// Locales: en
      static let motivationItemSmallCoin = Rswift.StringResource(key: "motivationItem.smallCoin", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en"], comment: nil)
      /// en translation: Start the challenge!
      ///
      /// Locales: ru, en
      static let guideThirdPageTitle = Rswift.StringResource(key: "guide.thirdPage.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["ru", "en"], comment: nil)
      /// en translation: Tap to change
      ///
      /// Locales: ru, en
      static let creationActionTitle = Rswift.StringResource(key: "creation.actionTitle", tableName: "Localizable", bundle: R.hostingBundle, locales: ["ru", "en"], comment: nil)
      /// en translation: This app is dedicated to help you focus on important things, without being distracted on messages, social networks or games.  To improve your motivation we challenge you to make a real bet that costs you money or time!
      ///
      /// Locales: ru, en
      static let guideFirstPageContent = Rswift.StringResource(key: "guide.firstPage.content", tableName: "Localizable", bundle: R.hostingBundle, locales: ["ru", "en"], comment: nil)
      /// en translation: Time
      ///
      /// Locales: ru, en
      static let creationTimeTitle = Rswift.StringResource(key: "creation.timeTitle", tableName: "Localizable", bundle: R.hostingBundle, locales: ["ru", "en"], comment: nil)
      /// en translation: Tiny Coin
      ///
      /// Locales: en
      static let motivationItemTinyCoin = Rswift.StringResource(key: "motivationItem.tinyCoin", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en"], comment: nil)
      /// en translation: Unlock App
      ///
      /// Locales: ru, en
      static let purchaseButtonTitle = Rswift.StringResource(key: "purchase.buttonTitle", tableName: "Localizable", bundle: R.hostingBundle, locales: ["ru", "en"], comment: nil)
      /// en translation: Watching Ad
      ///
      /// Locales: en
      static let motivationItemAd = Rswift.StringResource(key: "motivationItem.ad", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en"], comment: nil)
      /// en translation: You will lose your challenge if don't return to the app!
      ///
      /// Locales: ru, en
      static let notificationsReturnBody = Rswift.StringResource(key: "notifications.return.body", tableName: "Localizable", bundle: R.hostingBundle, locales: ["ru", "en"], comment: nil)

      /// en translation: %#@value@
      ///
      /// Locales: en, ru
      static func timerMinLeft(value value1: Int, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("timer.minLeft", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "timer.minLeft"
        }

        let format = NSLocalizedString("timer.minLeft", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1)
      }

      /// en translation: 1. Set task time.  2. Make a bet. You might choose between time and money, it will highly increase your motivation!  3. The main rule is simple - do not leave the app. You can lock your phone or stay on the challenge screen.
      ///
      /// Locales: ru, en
      static func guideSecondPageContent(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("guide.secondPage.content", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "guide.secondPage.content"
        }

        return NSLocalizedString("guide.secondPage.content", bundle: bundle, comment: "")
      }

      /// en translation: Big Coin
      ///
      /// Locales: en
      static func motivationItemBigCoin(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("motivationItem.bigCoin", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "motivationItem.bigCoin"
        }

        return NSLocalizedString("motivationItem.bigCoin", bundle: bundle, comment: "")
      }

      /// en translation: Click to avoid losing!
      ///
      /// Locales: ru, en
      static func notificationsReturnTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("notifications.return.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "notifications.return.title"
        }

        return NSLocalizedString("notifications.return.title", bundle: bundle, comment: "")
      }

      /// en translation: Does your task require concentration?
      ///
      /// Locales: ru, en
      static func guideSecondPageTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("guide.secondPage.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "guide.secondPage.title"
        }

        return NSLocalizedString("guide.secondPage.title", bundle: bundle, comment: "")
      }

      /// en translation: Follow the rules, stay focused and remember — time is money and you might lose it!
      ///
      /// Locales: ru, en
      static func guideThirdPageContent(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("guide.thirdPage.content", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "guide.thirdPage.content"
        }

        return NSLocalizedString("guide.thirdPage.content", bundle: bundle, comment: "")
      }

      /// en translation: Got it!
      ///
      /// Locales: ru, en
      static func guideGotIt(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("guide.gotIt", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "guide.gotIt"
        }

        return NSLocalizedString("guide.gotIt", bundle: bundle, comment: "")
      }

      /// en translation: Hello!
      ///
      /// Locales: ru, en
      static func guideFirstPageTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("guide.firstPage.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "guide.firstPage.title"
        }

        return NSLocalizedString("guide.firstPage.title", bundle: bundle, comment: "")
      }

      /// en translation: Huge Coin
      ///
      /// Locales: en
      static func motivationItemHugeCoin(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("motivationItem.hugeCoin", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "motivationItem.hugeCoin"
        }

        return NSLocalizedString("motivationItem.hugeCoin", bundle: bundle, comment: "")
      }

      /// en translation: In order to unlock the app you need to make a purchase equal to your challenge bet
      ///
      /// Locales: ru, en
      static func purchaseLoseMessage(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("purchase.loseMessage", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "purchase.loseMessage"
        }

        return NSLocalizedString("purchase.loseMessage", bundle: bundle, comment: "")
      }

      /// en translation: Localized string
      ///
      /// Locales: ru, en
      static func alertExample(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("alert.example", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "alert.example"
        }

        return NSLocalizedString("alert.example", bundle: bundle, comment: "")
      }

      /// en translation: Medium Coin
      ///
      /// Locales: en
      static func motivationItemMediumCoin(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("motivationItem.mediumCoin", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "motivationItem.mediumCoin"
        }

        return NSLocalizedString("motivationItem.mediumCoin", bundle: bundle, comment: "")
      }

      /// en translation: Motivation
      ///
      /// Locales: ru, en
      static func creationMotivationTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("creation.motivationTitle", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "creation.motivationTitle"
        }

        return NSLocalizedString("creation.motivationTitle", bundle: bundle, comment: "")
      }

      /// en translation: Next
      ///
      /// Locales: ru, en
      static func guideNext(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("guide.next", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "guide.next"
        }

        return NSLocalizedString("guide.next", bundle: bundle, comment: "")
      }

      /// en translation: Skip
      ///
      /// Locales: ru, en
      static func guideSkip(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("guide.skip", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "guide.skip"
        }

        return NSLocalizedString("guide.skip", bundle: bundle, comment: "")
      }

      /// en translation: Small Coin
      ///
      /// Locales: en
      static func motivationItemSmallCoin(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("motivationItem.smallCoin", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "motivationItem.smallCoin"
        }

        return NSLocalizedString("motivationItem.smallCoin", bundle: bundle, comment: "")
      }

      /// en translation: Start the challenge!
      ///
      /// Locales: ru, en
      static func guideThirdPageTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("guide.thirdPage.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "guide.thirdPage.title"
        }

        return NSLocalizedString("guide.thirdPage.title", bundle: bundle, comment: "")
      }

      /// en translation: Tap to change
      ///
      /// Locales: ru, en
      static func creationActionTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("creation.actionTitle", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "creation.actionTitle"
        }

        return NSLocalizedString("creation.actionTitle", bundle: bundle, comment: "")
      }

      /// en translation: This app is dedicated to help you focus on important things, without being distracted on messages, social networks or games.  To improve your motivation we challenge you to make a real bet that costs you money or time!
      ///
      /// Locales: ru, en
      static func guideFirstPageContent(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("guide.firstPage.content", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "guide.firstPage.content"
        }

        return NSLocalizedString("guide.firstPage.content", bundle: bundle, comment: "")
      }

      /// en translation: Time
      ///
      /// Locales: ru, en
      static func creationTimeTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("creation.timeTitle", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "creation.timeTitle"
        }

        return NSLocalizedString("creation.timeTitle", bundle: bundle, comment: "")
      }

      /// en translation: Tiny Coin
      ///
      /// Locales: en
      static func motivationItemTinyCoin(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("motivationItem.tinyCoin", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "motivationItem.tinyCoin"
        }

        return NSLocalizedString("motivationItem.tinyCoin", bundle: bundle, comment: "")
      }

      /// en translation: Unlock App
      ///
      /// Locales: ru, en
      static func purchaseButtonTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("purchase.buttonTitle", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "purchase.buttonTitle"
        }

        return NSLocalizedString("purchase.buttonTitle", bundle: bundle, comment: "")
      }

      /// en translation: Watching Ad
      ///
      /// Locales: en
      static func motivationItemAd(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("motivationItem.ad", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "motivationItem.ad"
        }

        return NSLocalizedString("motivationItem.ad", bundle: bundle, comment: "")
      }

      /// en translation: You will lose your challenge if don't return to the app!
      ///
      /// Locales: ru, en
      static func notificationsReturnBody(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("notifications.return.body", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "notifications.return.body"
        }

        return NSLocalizedString("notifications.return.body", bundle: bundle, comment: "")
      }

      fileprivate init() {}
    }

    /// This `R.string.settings` struct is generated, and contains static references to 3 localization keys.
    struct settings {
      /// ru translation: Selected Song: 
      ///
      /// Locales: ru
      static let ipOLQGqEText = Rswift.StringResource(key: "ipO-LQ-GqE.text", tableName: "Settings", bundle: R.hostingBundle, locales: ["ru"], comment: nil)
      /// ru translation: Song Name #1
      ///
      /// Locales: ru
      static let nzfHVP6gText = Rswift.StringResource(key: "Nzf-HV-P6g.text", tableName: "Settings", bundle: R.hostingBundle, locales: ["ru"], comment: nil)
      /// ru translation: Настройки
      ///
      /// Locales: ru
      static let gIYxX24Title = Rswift.StringResource(key: "0gI-Yx-x24.title", tableName: "Settings", bundle: R.hostingBundle, locales: ["ru"], comment: nil)

      /// ru translation: Selected Song: 
      ///
      /// Locales: ru
      static func ipOLQGqEText(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("ipO-LQ-GqE.text", tableName: "Settings", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Settings", preferredLanguages: preferredLanguages) else {
          return "ipO-LQ-GqE.text"
        }

        return NSLocalizedString("ipO-LQ-GqE.text", tableName: "Settings", bundle: bundle, comment: "")
      }

      /// ru translation: Song Name #1
      ///
      /// Locales: ru
      static func nzfHVP6gText(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("Nzf-HV-P6g.text", tableName: "Settings", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Settings", preferredLanguages: preferredLanguages) else {
          return "Nzf-HV-P6g.text"
        }

        return NSLocalizedString("Nzf-HV-P6g.text", tableName: "Settings", bundle: bundle, comment: "")
      }

      /// ru translation: Настройки
      ///
      /// Locales: ru
      static func gIYxX24Title(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("0gI-Yx-x24.title", tableName: "Settings", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Settings", preferredLanguages: preferredLanguages) else {
          return "0gI-Yx-x24.title"
        }

        return NSLocalizedString("0gI-Yx-x24.title", tableName: "Settings", bundle: bundle, comment: "")
      }

      fileprivate init() {}
    }

    fileprivate init() {}
  }

  fileprivate struct intern: Rswift.Validatable {
    fileprivate static func validate() throws {
      try _R.validate()
    }

    fileprivate init() {}
  }

  fileprivate class Class {}

  fileprivate init() {}
}

struct _R: Rswift.Validatable {
  static func validate() throws {
    #if os(iOS) || os(tvOS)
    try nib.validate()
    #endif
    #if os(iOS) || os(tvOS)
    try storyboard.validate()
    #endif
  }

  #if os(iOS) || os(tvOS)
  struct nib: Rswift.Validatable {
    static func validate() throws {
      try _PageCollectionViewCell.validate()
    }

    struct _ChallengeParameterView: Rswift.NibResourceType {
      let bundle = R.hostingBundle
      let name = "ChallengeParameterView"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
      }

      fileprivate init() {}
    }

    struct _PageCollectionViewCell: Rswift.NibResourceType, Rswift.ReuseIdentifierType, Rswift.Validatable {
      typealias ReusableType = PageCollectionViewCell

      let bundle = R.hostingBundle
      let identifier = "PageCollectionViewCell"
      let name = "PageCollectionViewCell"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> PageCollectionViewCell? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? PageCollectionViewCell
      }

      static func validate() throws {
        if UIKit.UIImage(named: "testIcon", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'testIcon' is used in nib 'PageCollectionViewCell', but couldn't be loaded.") }
        if #available(iOS 11.0, tvOS 11.0, *) {
          if UIKit.UIColor(named: "CTBlack", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'CTBlack' is used in storyboard 'PageCollectionViewCell', but couldn't be loaded.") }
        }
      }

      fileprivate init() {}
    }

    fileprivate init() {}
  }
  #endif

  #if os(iOS) || os(tvOS)
  struct storyboard: Rswift.Validatable {
    static func validate() throws {
      #if os(iOS) || os(tvOS)
      try ad.validate()
      #endif
      #if os(iOS) || os(tvOS)
      try alert.validate()
      #endif
      #if os(iOS) || os(tvOS)
      try blocked.validate()
      #endif
      #if os(iOS) || os(tvOS)
      try createChallenge.validate()
      #endif
      #if os(iOS) || os(tvOS)
      try currentChallenge.validate()
      #endif
      #if os(iOS) || os(tvOS)
      try guide.validate()
      #endif
      #if os(iOS) || os(tvOS)
      try history.validate()
      #endif
      #if os(iOS) || os(tvOS)
      try launchScreen.validate()
      #endif
      #if os(iOS) || os(tvOS)
      try motivationSelection.validate()
      #endif
      #if os(iOS) || os(tvOS)
      try pageNavigation.validate()
      #endif
      #if os(iOS) || os(tvOS)
      try settings.validate()
      #endif
      #if os(iOS) || os(tvOS)
      try timeSelection.validate()
      #endif
    }

    #if os(iOS) || os(tvOS)
    struct ad: Rswift.StoryboardResourceType, Rswift.Validatable {
      let adViewController = StoryboardViewControllerResource<AdViewController>(identifier: "AdViewController")
      let bundle = R.hostingBundle
      let name = "Ad"

      func adViewController(_: Void = ()) -> AdViewController? {
        return UIKit.UIStoryboard(resource: self).instantiateViewController(withResource: adViewController)
      }

      static func validate() throws {
        if #available(iOS 11.0, tvOS 11.0, *) {
          if UIKit.UIColor(named: "CTWhite", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'CTWhite' is used in storyboard 'Ad', but couldn't be loaded.") }
        }
        if _R.storyboard.ad().adViewController() == nil { throw Rswift.ValidationError(description:"[R.swift] ViewController with identifier 'adViewController' could not be loaded from storyboard 'Ad' as 'AdViewController'.") }
      }

      fileprivate init() {}
    }
    #endif

    #if os(iOS) || os(tvOS)
    struct alert: Rswift.StoryboardResourceType, Rswift.Validatable {
      let alertViewController = StoryboardViewControllerResource<AlertViewController>(identifier: "AlertViewController")
      let bundle = R.hostingBundle
      let name = "Alert"

      func alertViewController(_: Void = ()) -> AlertViewController? {
        return UIKit.UIStoryboard(resource: self).instantiateViewController(withResource: alertViewController)
      }

      static func validate() throws {
        if #available(iOS 11.0, tvOS 11.0, *) {
        }
        if _R.storyboard.alert().alertViewController() == nil { throw Rswift.ValidationError(description:"[R.swift] ViewController with identifier 'alertViewController' could not be loaded from storyboard 'Alert' as 'AlertViewController'.") }
      }

      fileprivate init() {}
    }
    #endif

    #if os(iOS) || os(tvOS)
    struct blocked: Rswift.StoryboardResourceType, Rswift.Validatable {
      let blockedViewController = StoryboardViewControllerResource<BlockedViewController>(identifier: "BlockedViewController")
      let bundle = R.hostingBundle
      let name = "Blocked"

      func blockedViewController(_: Void = ()) -> BlockedViewController? {
        return UIKit.UIStoryboard(resource: self).instantiateViewController(withResource: blockedViewController)
      }

      static func validate() throws {
        if #available(iOS 11.0, tvOS 11.0, *) {
          if UIKit.UIColor(named: "CTWhite", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'CTWhite' is used in storyboard 'Blocked', but couldn't be loaded.") }
        }
        if _R.storyboard.blocked().blockedViewController() == nil { throw Rswift.ValidationError(description:"[R.swift] ViewController with identifier 'blockedViewController' could not be loaded from storyboard 'Blocked' as 'BlockedViewController'.") }
      }

      fileprivate init() {}
    }
    #endif

    #if os(iOS) || os(tvOS)
    struct createChallenge: Rswift.StoryboardResourceType, Rswift.Validatable {
      let bundle = R.hostingBundle
      let createChallengeViewController = StoryboardViewControllerResource<CreateChallengeViewController>(identifier: "CreateChallengeViewController")
      let name = "CreateChallenge"

      func createChallengeViewController(_: Void = ()) -> CreateChallengeViewController? {
        return UIKit.UIStoryboard(resource: self).instantiateViewController(withResource: createChallengeViewController)
      }

      static func validate() throws {
        if UIKit.UIImage(named: "testIcon", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'testIcon' is used in storyboard 'CreateChallenge', but couldn't be loaded.") }
        if #available(iOS 11.0, tvOS 11.0, *) {
          if UIKit.UIColor(named: "AppColor", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'AppColor' is used in storyboard 'CreateChallenge', but couldn't be loaded.") }
          if UIKit.UIColor(named: "BackgroundBlue", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'BackgroundBlue' is used in storyboard 'CreateChallenge', but couldn't be loaded.") }
          if UIKit.UIColor(named: "CTOrange", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'CTOrange' is used in storyboard 'CreateChallenge', but couldn't be loaded.") }
          if UIKit.UIColor(named: "CTWhite", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'CTWhite' is used in storyboard 'CreateChallenge', but couldn't be loaded.") }
          if UIKit.UIColor(named: "LightBlue", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'LightBlue' is used in storyboard 'CreateChallenge', but couldn't be loaded.") }
        }
        if _R.storyboard.createChallenge().createChallengeViewController() == nil { throw Rswift.ValidationError(description:"[R.swift] ViewController with identifier 'createChallengeViewController' could not be loaded from storyboard 'CreateChallenge' as 'CreateChallengeViewController'.") }
      }

      fileprivate init() {}
    }
    #endif

    #if os(iOS) || os(tvOS)
    struct currentChallenge: Rswift.StoryboardResourceType, Rswift.Validatable {
      let bundle = R.hostingBundle
      let currentChallengeViewController = StoryboardViewControllerResource<CurrentChallengeViewController>(identifier: "CurrentChallengeViewController")
      let name = "CurrentChallenge"

      func currentChallengeViewController(_: Void = ()) -> CurrentChallengeViewController? {
        return UIKit.UIStoryboard(resource: self).instantiateViewController(withResource: currentChallengeViewController)
      }

      static func validate() throws {
        if UIKit.UIImage(named: "music.note.list", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'music.note.list' is used in storyboard 'CurrentChallenge', but couldn't be loaded.") }
        if UIKit.UIImage(named: "play", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'play' is used in storyboard 'CurrentChallenge', but couldn't be loaded.") }
        if #available(iOS 11.0, tvOS 11.0, *) {
          if UIKit.UIColor(named: "CTOrange", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'CTOrange' is used in storyboard 'CurrentChallenge', but couldn't be loaded.") }
          if UIKit.UIColor(named: "CTWhite", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'CTWhite' is used in storyboard 'CurrentChallenge', but couldn't be loaded.") }
        }
        if _R.storyboard.currentChallenge().currentChallengeViewController() == nil { throw Rswift.ValidationError(description:"[R.swift] ViewController with identifier 'currentChallengeViewController' could not be loaded from storyboard 'CurrentChallenge' as 'CurrentChallengeViewController'.") }
      }

      fileprivate init() {}
    }
    #endif

    #if os(iOS) || os(tvOS)
    struct guide: Rswift.StoryboardResourceType, Rswift.Validatable {
      let bundle = R.hostingBundle
      let guideViewController = StoryboardViewControllerResource<GuideViewController>(identifier: "GuideViewController")
      let name = "Guide"

      func guideViewController(_: Void = ()) -> GuideViewController? {
        return UIKit.UIStoryboard(resource: self).instantiateViewController(withResource: guideViewController)
      }

      static func validate() throws {
        if #available(iOS 11.0, tvOS 11.0, *) {
          if UIKit.UIColor(named: "CTGray", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'CTGray' is used in storyboard 'Guide', but couldn't be loaded.") }
          if UIKit.UIColor(named: "CTOrange", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'CTOrange' is used in storyboard 'Guide', but couldn't be loaded.") }
        }
        if _R.storyboard.guide().guideViewController() == nil { throw Rswift.ValidationError(description:"[R.swift] ViewController with identifier 'guideViewController' could not be loaded from storyboard 'Guide' as 'GuideViewController'.") }
      }

      fileprivate init() {}
    }
    #endif

    #if os(iOS) || os(tvOS)
    struct history: Rswift.StoryboardResourceType, Rswift.Validatable {
      let bundle = R.hostingBundle
      let historyViewController = StoryboardViewControllerResource<HistoryViewController>(identifier: "HistoryViewController")
      let name = "History"

      func historyViewController(_: Void = ()) -> HistoryViewController? {
        return UIKit.UIStoryboard(resource: self).instantiateViewController(withResource: historyViewController)
      }

      static func validate() throws {
        if #available(iOS 11.0, tvOS 11.0, *) {
          if UIKit.UIColor(named: "CTGray", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'CTGray' is used in storyboard 'History', but couldn't be loaded.") }
          if UIKit.UIColor(named: "CTWhite", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'CTWhite' is used in storyboard 'History', but couldn't be loaded.") }
        }
        if _R.storyboard.history().historyViewController() == nil { throw Rswift.ValidationError(description:"[R.swift] ViewController with identifier 'historyViewController' could not be loaded from storyboard 'History' as 'HistoryViewController'.") }
      }

      fileprivate init() {}
    }
    #endif

    #if os(iOS) || os(tvOS)
    struct launchScreen: Rswift.StoryboardResourceWithInitialControllerType, Rswift.Validatable {
      typealias InitialController = UIKit.UIViewController

      let bundle = R.hostingBundle
      let name = "LaunchScreen"

      static func validate() throws {
        if UIKit.UIImage(named: "launch_cat", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'launch_cat' is used in storyboard 'LaunchScreen', but couldn't be loaded.") }
        if UIKit.UIImage(named: "launch_title", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'launch_title' is used in storyboard 'LaunchScreen', but couldn't be loaded.") }
        if #available(iOS 11.0, tvOS 11.0, *) {
          if UIKit.UIColor(named: "CTBlue", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'CTBlue' is used in storyboard 'LaunchScreen', but couldn't be loaded.") }
        }
      }

      fileprivate init() {}
    }
    #endif

    #if os(iOS) || os(tvOS)
    struct motivationSelection: Rswift.StoryboardResourceType, Rswift.Validatable {
      let bundle = R.hostingBundle
      let motivatonSelectionViewController = StoryboardViewControllerResource<MotivatonSelectionViewController>(identifier: "MotivatonSelectionViewController")
      let name = "MotivationSelection"

      func motivatonSelectionViewController(_: Void = ()) -> MotivatonSelectionViewController? {
        return UIKit.UIStoryboard(resource: self).instantiateViewController(withResource: motivatonSelectionViewController)
      }

      static func validate() throws {
        if UIKit.UIImage(named: "testIcon", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'testIcon' is used in storyboard 'MotivationSelection', but couldn't be loaded.") }
        if #available(iOS 11.0, tvOS 11.0, *) {
          if UIKit.UIColor(named: "AppColor", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'AppColor' is used in storyboard 'MotivationSelection', but couldn't be loaded.") }
          if UIKit.UIColor(named: "CTOrange", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'CTOrange' is used in storyboard 'MotivationSelection', but couldn't be loaded.") }
          if UIKit.UIColor(named: "CTWhite", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'CTWhite' is used in storyboard 'MotivationSelection', but couldn't be loaded.") }
        }
        if _R.storyboard.motivationSelection().motivatonSelectionViewController() == nil { throw Rswift.ValidationError(description:"[R.swift] ViewController with identifier 'motivatonSelectionViewController' could not be loaded from storyboard 'MotivationSelection' as 'MotivatonSelectionViewController'.") }
      }

      fileprivate init() {}
    }
    #endif

    #if os(iOS) || os(tvOS)
    struct pageNavigation: Rswift.StoryboardResourceType, Rswift.Validatable {
      let bundle = R.hostingBundle
      let name = "PageNavigation"
      let pageNavigationViewController = StoryboardViewControllerResource<PageNavigationViewController>(identifier: "PageNavigationViewController")

      func pageNavigationViewController(_: Void = ()) -> PageNavigationViewController? {
        return UIKit.UIStoryboard(resource: self).instantiateViewController(withResource: pageNavigationViewController)
      }

      static func validate() throws {
        if #available(iOS 11.0, tvOS 11.0, *) {
        }
        if _R.storyboard.pageNavigation().pageNavigationViewController() == nil { throw Rswift.ValidationError(description:"[R.swift] ViewController with identifier 'pageNavigationViewController' could not be loaded from storyboard 'PageNavigation' as 'PageNavigationViewController'.") }
      }

      fileprivate init() {}
    }
    #endif

    #if os(iOS) || os(tvOS)
    struct settings: Rswift.StoryboardResourceType, Rswift.Validatable {
      let bundle = R.hostingBundle
      let musicSelectViewController = StoryboardViewControllerResource<MusicSelectViewController>(identifier: "MusicSelectViewController")
      let name = "Settings"
      let settingsViewController = StoryboardViewControllerResource<SettingsViewController>(identifier: "SettingsViewController")

      func musicSelectViewController(_: Void = ()) -> MusicSelectViewController? {
        return UIKit.UIStoryboard(resource: self).instantiateViewController(withResource: musicSelectViewController)
      }

      func settingsViewController(_: Void = ()) -> SettingsViewController? {
        return UIKit.UIStoryboard(resource: self).instantiateViewController(withResource: settingsViewController)
      }

      static func validate() throws {
        if UIKit.UIImage(named: "play", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'play' is used in storyboard 'Settings', but couldn't be loaded.") }
        if #available(iOS 11.0, tvOS 11.0, *) {
          if UIKit.UIColor(named: "CTBlack", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'CTBlack' is used in storyboard 'Settings', but couldn't be loaded.") }
          if UIKit.UIColor(named: "CTGray", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'CTGray' is used in storyboard 'Settings', but couldn't be loaded.") }
          if UIKit.UIColor(named: "CTOrange", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'CTOrange' is used in storyboard 'Settings', but couldn't be loaded.") }
          if UIKit.UIColor(named: "CTWhite", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'CTWhite' is used in storyboard 'Settings', but couldn't be loaded.") }
        }
        if _R.storyboard.settings().musicSelectViewController() == nil { throw Rswift.ValidationError(description:"[R.swift] ViewController with identifier 'musicSelectViewController' could not be loaded from storyboard 'Settings' as 'MusicSelectViewController'.") }
        if _R.storyboard.settings().settingsViewController() == nil { throw Rswift.ValidationError(description:"[R.swift] ViewController with identifier 'settingsViewController' could not be loaded from storyboard 'Settings' as 'SettingsViewController'.") }
      }

      fileprivate init() {}
    }
    #endif

    #if os(iOS) || os(tvOS)
    struct timeSelection: Rswift.StoryboardResourceType, Rswift.Validatable {
      let bundle = R.hostingBundle
      let name = "TimeSelection"
      let timeSelectionViewController = StoryboardViewControllerResource<TimeSelectionViewController>(identifier: "TimeSelectionViewController")

      func timeSelectionViewController(_: Void = ()) -> TimeSelectionViewController? {
        return UIKit.UIStoryboard(resource: self).instantiateViewController(withResource: timeSelectionViewController)
      }

      static func validate() throws {
        if UIKit.UIImage(named: "testIcon", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'testIcon' is used in storyboard 'TimeSelection', but couldn't be loaded.") }
        if #available(iOS 11.0, tvOS 11.0, *) {
          if UIKit.UIColor(named: "AppColor", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'AppColor' is used in storyboard 'TimeSelection', but couldn't be loaded.") }
          if UIKit.UIColor(named: "CTOrange", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'CTOrange' is used in storyboard 'TimeSelection', but couldn't be loaded.") }
          if UIKit.UIColor(named: "CTWhite", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'CTWhite' is used in storyboard 'TimeSelection', but couldn't be loaded.") }
          if UIKit.UIColor(named: "LightBlue", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'LightBlue' is used in storyboard 'TimeSelection', but couldn't be loaded.") }
        }
        if _R.storyboard.timeSelection().timeSelectionViewController() == nil { throw Rswift.ValidationError(description:"[R.swift] ViewController with identifier 'timeSelectionViewController' could not be loaded from storyboard 'TimeSelection' as 'TimeSelectionViewController'.") }
      }

      fileprivate init() {}
    }
    #endif

    fileprivate init() {}
  }
  #endif

  fileprivate init() {}
}
